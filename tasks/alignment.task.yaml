name: Tumor/Normal Alignment with pbmm2
description: Align reads with pbmm2
auto_generate_session_for_account: "{workspaceBot}"

agent_requirements:
  cpu_cores: 48
  memory_gb: 96

parameters:
  - name: input_bams
    label: Input BAM Files
    type: file
    pattern_match:
      - '*.bam'
    list: true
    help: The uBAM (unaligned BAM) files to align. Multiple files can be provided and will be aligned and merged.

  - name: output_folder
    label: Output Folder
    type: directory
    supports_location_mode: 'no_append'
    help: The output folder for the alignment results.

  - name: sample_name
    label: Sample Name
    type: string
    help: The name of the sample to align. 

  - name: cache_udocker_images
    label: Cache Udocker Image
    type: boolean
    value: true

steps:
  - name: alignment
    description: Align reads with pbmm2
    type: cmd
    args: 
      - |- # shell
        set -eu pipefail

        echo "*************************"
        echo "Starting Tumor/Normal Alignment Task"
        echo "Space on agent: $(df -h /scratch | tail -n 1 | awk '{print $4}')"
        echo "Input Parameters:"
        echo "  - input_bams: $input_bams"
        echo "  - output_folder: $output_folder"
        echo "  - sample_name: $sample_name"
        echo "  - cache_udocker_images: $cache_udocker_images"
        echo "*************************"
        
        # Validate that at least one BAM file is provided
        if [ -z "$input_bams" ] || [ "$input_bams" = "" ]; then
          echo "Error: No input BAM files provided"
          exit 1
        fi

        # Check if output files already exist
        echo "Checking if output files already exist..."
        OUTPUT_FILES_EXIST=true
        
        # Check for aligned BAM and index files
        ALIGNED_BAM="${output_folder}/${sample_name}.aligned.bam"
        ALIGNED_BAM_INDEX="${output_folder}/${sample_name}.aligned.bam.bai"
        
        # Also check for phased BAM (from hiphase) - if it exists, alignment has already completed
        PHASED_BAM="${output_folder}/${sample_name}.hiphase.bam"
        PHASED_BAM_INDEX="${output_folder}/${sample_name}.hiphase.bam.bai"
        
        if [ ! -f "$ALIGNED_BAM" ] || [ ! -f "$ALIGNED_BAM_INDEX" ]; then
          if [ ! -f "$PHASED_BAM" ] || [ ! -f "$PHASED_BAM_INDEX" ]; then
            OUTPUT_FILES_EXIST=false
            echo "  - Alignment output files missing (aligned and phased BAMs)"
          else
            echo "  - Phased BAM exists, skipping alignment"
          fi
        fi
        
        if [ "$OUTPUT_FILES_EXIST" = true ]; then
          echo "All output files already exist. Skipping task as no-op."
          echo "*************************"
          echo "Tumor/Normal Alignment Task completed (skipped - outputs exist)"
          echo "*************************"
          exit 0
        else
          echo "Output files missing. Proceeding with analysis..."
        fi

        # Source common utility functions
        source "$TASK_DIR/utils/utils.sh"

        # Set up resources path based on resources_path
        PB_RESOURCES_DIR="${WORKSPACE_DIR}/${RESOURCES_PATH}/hifisomatic_resources"

        # set up env variables for miniwdl
        export MINIWDL__SCHEDULER__CONTAINER_BACKEND=udocker
        export MINIWDL__FILE_IO__ALLOW_ANY_INPUT=true
        export MINIWDL__SCHEDULER__TASK_CONCURRENCY=8
        export UDOCKER_DIR=/scratch/.udocker

        # Get reference files
        REF_FASTA="$PB_RESOURCES_DIR/GCA_000001405.15_GRCh38_no_alt_analysis_set_maskedGRC_exclusions_v2.fasta"
        REF_INDEX="$PB_RESOURCES_DIR/GCA_000001405.15_GRCh38_no_alt_analysis_set_maskedGRC_exclusions_v2.fasta.fai"

        # verify reference files exist
        if [ ! -f "$REF_FASTA" ]; then
          echo "Error: Reference FASTA file not found at $REF_FASTA"
          echo "Please ensure the PacBio WDL resources have been downloaded using the Download PacBio Reference Data Resources task"
          exit 1
        fi
        
        if [ ! -f "$REF_INDEX" ]; then
          echo "Error: Reference FASTA index file not found at $REF_INDEX"
          echo "Please ensure the PacBio WDL resources have been downloaded using the Download PacBio Reference Data Resources task"
          exit 1
        fi
        
        # copy reference files to /scratch
        echo "Copying reference files to /scratch..."
        copy_with_progress "/scratch" "$REF_FASTA" "$REF_INDEX"
        LOCAL_REF_FASTA="/scratch/$(basename "$REF_FASTA")"
        LOCAL_REF_INDEX="/scratch/$(basename "$REF_INDEX")"

        # Pull udocker layers from cache if requested
        if [ -d "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}" ] && [ "$cache_udocker_images" = true ]; then
          echo "Pulling udocker image from cache..."
          mkdir -p /scratch/.udocker
          cp -R "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}"/* /scratch/.udocker/ > /dev/null 2>&1 || \
            { echo "Failed to copy udocker cache to /scratch/.udocker; will pull layers instead"; }
        fi
        
        # Check whether sample is tumor or normal in catalog
        echo "Checking sample type in catalog..."
        set +e
        sample_type=$(gautil client catalog-export SampleCatalog Sample:eq:"$sample_name" --fields="Tumor" | tail -n 1 | tr -d '\r\n\t ')
        sample_type_lookup_exit_code=$?
        set -e
        echo "Sample type: $sample_type"
        
        if [ $sample_type_lookup_exit_code -ne 0 ] || [ -z "$sample_type" ] || [ "$sample_type" != "Tumor" ] && [ "$sample_type" != "Normal" ]; then
          sample_type="Tumor"
        fi
        if [ "$sample_type" = "Normal" ]; then
          sample_type="normal"
        else
          sample_type="tumor"
        fi

        # Ensure output folder exists
        mkdir -p "$output_folder"

        # Process input BAM files and format as JSON array
        echo "Processing input BAM files and formatting as JSON array..."
        
        # Parse list of input files (comma-separated when list: true is used)
        # Handle both single files and comma-separated lists properly
        if [[ "$input_bams" == *,* ]]; then
          # Multiple files separated by commas
          IFS=',' read -ra temp_input_files <<< "$input_bams"
          # Filter out empty strings
          input_files=()
          for file in "${temp_input_files[@]}"; do
            if [ ! -z "$file" ]; then
              input_files+=("$file")
            fi
          done
        else
          # Single file - create array with single element
          input_files=("$input_bams")
        fi
        
        # Build JSON array from input files
        input_bams_json="["
        first=true
        for bam_file in "${input_files[@]}"; do
          # Verify file exists
          if [ ! -f "$bam_file" ]; then
            echo "Warning: Input BAM file not found: $bam_file, skipping"
            continue
          fi
          
          if [ "$first" = true ]; then
            first=false
          else
            input_bams_json="$input_bams_json,"
          fi
          # Use absolute path for the BAM file
          abs_bam_path=$(readlink -f "$bam_file" 2>/dev/null || echo "$bam_file")
          input_bams_json="$input_bams_json\"$abs_bam_path\""
          echo "  - Added BAM file: $bam_file"
        done
        input_bams_json="$input_bams_json]"
        
        # Validate that we have at least one valid BAM file
        bam_count=$(echo "$input_bams_json" | jq -r 'length')
        if [ "$bam_count" -eq 0 ]; then
          echo "Error: No valid input BAM files found"
          exit 1
        fi
        
        echo "Input BAM files JSON: $input_bams_json"
        echo "Total BAM files: $bam_count"

        # Run Alignment
        echo "================================================"
        echo "ðŸš€ STARTING ALIGNMENT"
        echo "================================================"
        echo "ðŸ“… Server Time: $(date)"
        echo "ðŸ“ Input Files:"
        echo "  - Reference FASTA: $(basename "$LOCAL_REF_FASTA") ($(format_file_size "$LOCAL_REF_FASTA"))"
        echo "  - Reference Index: $(basename "$LOCAL_REF_INDEX") ($(format_file_size "$LOCAL_REF_INDEX"))"
        echo "  - Input BAMs: $(echo "$input_bams_json" | jq -r 'length') files"
        echo "âš™ï¸  Configuration:"
        echo "  - Sample Name: $sample_name"
        echo "  - Sample Type: $sample_type"
        echo "  - Threads: $AGENT_CPU_CORES"
        echo "================================================"
        
        # Record start time
        ALIGNMENT_START_TIME=$(date +%s)
        
        # Generate alignment input JSON
        jq -n \
          --arg patient "$sample_name" \
          --argjson bam_files "$input_bams_json" \
          --arg ref_fasta "$LOCAL_REF_FASTA" \
          --arg ref_fasta_index "$LOCAL_REF_INDEX" \
          '{
            "align_all_bams.patient": $patient,
            "align_all_bams.bam_files": $bam_files,
            "align_all_bams.ref_fasta": $ref_fasta,
            "align_all_bams.ref_fasta_index": $ref_fasta_index
          }' > /scratch/inputs.json

        # Run miniwdl and capture exit code, but don't exit on failure
        echo "Running miniwdl..."
        set +e
        miniwdl run \
          "${TASK_DIR}/HiFi-somatic-WDL-0.9.2/tasks/alignment.wdl" \
          --dir /scratch \
          --runtime-cpu-max=$AGENT_CPU_CORES \
          --runtime-memory-max=${AGENT_MEMORY_GB}G \
          -i /scratch/inputs.json 2>/dev/null

        MINIWDL_EXIT_CODE=$?
        set -e

        # Post-execution logging for Alignment
        ALIGNMENT_END_TIME=$(date +%s)
        ALIGNMENT_DURATION=$((ALIGNMENT_END_TIME - ALIGNMENT_START_TIME))
        ALIGNMENT_DURATION_HOUR=$((ALIGNMENT_DURATION / 3600))
        ALIGNMENT_DURATION_MIN=$(((ALIGNMENT_DURATION % 3600) / 60))
        ALIGNMENT_DURATION_SEC=$((ALIGNMENT_DURATION % 60))
        
        echo "================================================"
        echo "âœ… ALIGNMENT COMPLETED SUCCESSFULLY"
        echo "================================================"
        echo "â±ï¸  Execution Time: ${ALIGNMENT_DURATION_HOUR}h ${ALIGNMENT_DURATION_MIN}m ${ALIGNMENT_DURATION_SEC}s"
        echo "ðŸ“ Output Files:"
        echo "  - Aligned BAM: ${sample_name}.aligned.bam"
        echo "  - BAM Index: ${sample_name}.aligned.bam.bai"
        echo "================================================"

        # Copy udocker cache to output folder
        if [ "$cache_udocker_images" = true ] && [ ! -d "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}" ]; then
          echo "Copying udocker cache to resources folder..."
          mkdir -p "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}"
          cp -r /scratch/.udocker/layers /scratch/.udocker/repos "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}" 2>/dev/null || true
        fi

        # Copy alignment outputs from MiniWDL to output folder
        echo "Copying alignment outputs to $output_folder..."
        if [ -f /scratch/_LAST/outputs.json ]; then
          ALIGNED_BAM=$(jq -r '.["align_all_bams.bam_final"]' /scratch/_LAST/outputs.json)
          ALIGNED_BAI=$(jq -r '.["align_all_bams.bam_final_index"]' /scratch/_LAST/outputs.json)
          if [ -n "$ALIGNED_BAM" ] && [ "$ALIGNED_BAM" != "null" ] && [ -f "$ALIGNED_BAM" ]; then
            cp "$ALIGNED_BAM" "$output_folder/${sample_name}.aligned.bam"
            echo "  - Copied: ${sample_name}.aligned.bam"
          fi
          if [ -n "$ALIGNED_BAI" ] && [ "$ALIGNED_BAI" != "null" ] && [ -f "$ALIGNED_BAI" ]; then
            cp "$ALIGNED_BAI" "$output_folder/${sample_name}.aligned.bam.bai"
            echo "  - Copied: ${sample_name}.aligned.bam.bai"
          fi
        else
          echo "Warning: outputs.json not found at /scratch/_LAST/outputs.json"
        fi

        if [ $MINIWDL_EXIT_CODE -ne 0 ]; then
          echo "MiniWDL run failed with exit code $MINIWDL_EXIT_CODE"
          handle_miniwdl_failure $MINIWDL_EXIT_CODE
        fi

        echo "*************************"
        echo "Alignment completed successfully"
        echo "Output files copied to: $output_folder"
        echo "*************************"
