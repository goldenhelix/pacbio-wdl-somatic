name: DeepSomatic
description: Call variants from PacBio HiFi aligned BAM using DeepSomatic.
auto_generate_session_for_account: "{workspaceBot}"

agent_requirements:
  cpu_cores: 48
  memory_gb: 96

parameters:
  - name: tumor_sample_name
    label: Sample Name (tumor)
    type: string

  - name: tumor_aligned_bam
    label: Tumor Aligned BAM
    type: file
    pattern_match:
      - '*.bam'
    
  - name: normal_aligned_bam
    label: Normal Aligned BAM (Optional)
    type: file
    pattern_match:
      - '*.bam'
    optional: true

  - name: normal_sample_name
    label: Normal Sample Name (Optional)
    type: string
    optional: true

  - name: output_folder
    label: Output Folder
    type: directory
    supports_location_mode: 'no_append'
  
  - name: cache_udocker_images
    label: Cache Udocker Image
    type: boolean
    value: true

steps:
  - name: deepsomatic
    type: cmd
    description: Call variants from PacBio HiFi aligned BAM using DeepSomatic.
    args:
      - |- # shell
        set -eu pipefail

        echo "*************************"
        echo "Starting DeepSomatic Task"
        echo "Space on agent: $(df -h /scratch | tail -n 1 | awk '{print $4}')"
        echo "Input Parameters:"
        echo "  - tumor_sample_name: $tumor_sample_name"
        echo "  - tumor_aligned_bam: $tumor_aligned_bam"
        echo "  - normal_aligned_bam: $normal_aligned_bam"
        echo "  - normal_sample_name: $normal_sample_name"
        echo "  - output_folder: $output_folder"
        echo "  - cache_udocker_images: $cache_udocker_images"
        echo "*************************"

        # Check if output files already exist
        echo "Checking if output files already exist..."
        OUTPUT_FILES_EXIST=true

        # Check if normal sample parameters are provided
        NORMAL_SAMPLE_PROVIDED=false
        if [ -n "$normal_sample_name" ] && [ -n "$normal_aligned_bam" ]; then
          NORMAL_SAMPLE_PROVIDED=true
          
          # Check if normal sample name matches the matched normal sample in sample catalog
          CATALOG_NORMAL_SAMPLE=$(gautil client catalog-export SampleCatalog Sample:eq:"$tumor_sample_name" --fields="NormalSample" | tail -n 1 | tr -d '\r\n\t ')
          
          if [ -n "$CATALOG_NORMAL_SAMPLE" ]; then
            if [ "$normal_sample_name" != "$CATALOG_NORMAL_SAMPLE" ]; then
              echo "Warning: Normal sample name '$normal_sample_name' does not match the matched normal sample '$CATALOG_NORMAL_SAMPLE' in the sample catalog for tumor sample '$tumor_sample_name'"
            fi
          fi
        elif [ -n "$normal_sample_name" ] || [ -n "$normal_aligned_bam" ]; then
          echo "Warning: Only one of normal sample name or normal BAM file is provided. Normal sample will be ignored."
        fi
        
        # Check for DeepSomatic output files with standardized naming
        DEEPSOMATIC_VCF_FILES=$(find "$output_folder" -name "${tumor_sample_name}.deepsomatic.vcf.gz" 2>/dev/null | wc -l)
        DEEPSOMATIC_GVCF_FILES=$(find "$output_folder" -name "${tumor_sample_name}.deepsomatic.g.vcf.gz" 2>/dev/null | wc -l)
        CLAIR3_TUMOR_VCF_FILES=$(find "$output_folder" -name "${tumor_sample_name}.clair3.small_variants.correct_ref.vcf.gz" 2>/dev/null | wc -l)
        
        # Check for normal Clair3 VCF files if normal sample is provided
        CLAIR3_NORMAL_VCF_FILES=0
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          CLAIR3_NORMAL_VCF_FILES=$(find "$output_folder" -name "${normal_sample_name}.clair3.small_variants.correct_ref.vcf.gz" 2>/dev/null | wc -l)
        fi
        
        # Check for mutational pattern output files based on actual WDL outputs
        MUTATIONAL_PROFILE_FILES=$(find "$output_folder" -name "*.mutation_profile.pdf" 2>/dev/null | wc -l)
        MUTATIONAL_SIG_FILES=$(find "$output_folder" -name "*.mut_sigs.tsv" 2>/dev/null | wc -l)
        MUTATIONAL_BOOTSTRAP_FILES=$(find "$output_folder" -name "*.mut_sigs_bootstrapped.tsv" 2>/dev/null | wc -l)
        MUTATIONAL_RECON_FILES=$(find "$output_folder" -name "*.reconstructed_sigs.tsv" 2>/dev/null | wc -l)
        MUTATIONAL_OCCURRENCE_FILES=$(find "$output_folder" -name "*.type_occurences.tsv" 2>/dev/null | wc -l)
        
        echo "  - Found $DEEPSOMATIC_VCF_FILES DeepSomatic VCF files (${tumor_sample_name}.deepsomatic.vcf.gz)"
        echo "  - Found $DEEPSOMATIC_GVCF_FILES DeepSomatic GVCF files (${tumor_sample_name}.deepsomatic.g.vcf.gz)"
        echo "  - Found $CLAIR3_TUMOR_VCF_FILES Clair3 tumor VCF files (${tumor_sample_name}.clair3.small_variants.correct_ref.vcf.gz)"
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          echo "  - Found $CLAIR3_NORMAL_VCF_FILES Clair3 normal VCF files (${normal_sample_name}.clair3.small_variants.correct_ref.vcf.gz)"
        fi
        echo "  - Found $MUTATIONAL_PROFILE_FILES mutation profile files"
        echo "  - Found $MUTATIONAL_SIG_FILES mutation signature files"
        echo "  - Found $MUTATIONAL_BOOTSTRAP_FILES bootstrap files"
        echo "  - Found $MUTATIONAL_RECON_FILES reconstructed signature files"
        echo "  - Found $MUTATIONAL_OCCURRENCE_FILES occurrence files"
        
        if [ $DEEPSOMATIC_VCF_FILES -eq 0 ] || [ $DEEPSOMATIC_GVCF_FILES -eq 0 ] || [ $CLAIR3_TUMOR_VCF_FILES -eq 0 ] || [ $MUTATIONAL_PROFILE_FILES -eq 0 ] || [ $MUTATIONAL_SIG_FILES -eq 0 ] || [ $MUTATIONAL_BOOTSTRAP_FILES -eq 0 ] || [ $MUTATIONAL_RECON_FILES -eq 0 ] || [ $MUTATIONAL_OCCURRENCE_FILES -eq 0 ]; then
          OUTPUT_FILES_EXIST=false
          echo "  - DeepSomatic output files missing"
        fi
        
        # Check normal Clair3 VCF files if normal sample is provided
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ] && [ $CLAIR3_NORMAL_VCF_FILES -eq 0 ]; then
          OUTPUT_FILES_EXIST=false
          echo "  - Normal Clair3 VCF files missing"
        fi
        
        if [ "$OUTPUT_FILES_EXIST" = true ]; then
          echo "All output files already exist. Skipping task as no-op."
          echo "*************************"
          echo "DeepSomatic Task completed (skipped - outputs exist)"
          echo "*************************"
          exit 0
        else
          echo "Output files missing. Proceeding with analysis..."
        fi

        # Source common utility functions
        source "$TASK_DIR/utils/utils.sh"

        # Set up resources path based on resources_path
        PB_RESOURCES_DIR="${WORKSPACE_DIR}/${RESOURCES_PATH}/hifisomatic_resources"

        # set up env variables for miniwdl
        export MINIWDL__SCHEDULER__CONTAINER_BACKEND=udocker
        export MINIWDL__FILE_IO__ALLOW_ANY_INPUT=true
        export MINIWDL__SCHEDULER__TASK_CONCURRENCY=8
        export UDOCKER_DIR=/scratch/.udocker
        
        # Set up reference files
        REF_FASTA="$PB_RESOURCES_DIR/GCA_000001405.15_GRCh38_no_alt_analysis_set_maskedGRC_exclusions_v2.fasta"
        REF_INDEX="$PB_RESOURCES_DIR/GCA_000001405.15_GRCh38_no_alt_analysis_set_maskedGRC_exclusions_v2.fasta.fai"

        # Verify reference files exist
        if [ ! -f "$REF_FASTA" ]; then
          echo "Error: Reference FASTA file not found at $REF_FASTA"
          exit 1
        fi
        
        if [ ! -f "$REF_INDEX" ]; then
          echo "Error: Reference FASTA index file not found at $REF_INDEX"
          exit 1
        fi

        # Copy reference files to /scratch
        echo "Copying reference files to /scratch..."
        copy_with_progress "/scratch" "$REF_FASTA" "$REF_INDEX"
        LOCAL_REF_FASTA="/scratch/$(basename "$REF_FASTA")"
        LOCAL_REF_INDEX="/scratch/$(basename "$REF_INDEX")"

        # Pull udocker layers from cache if requested
        if [ -d "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}" ] && [ "$cache_udocker_images" = true ]; then
          echo "Pulling udocker image from cache..."
          mkdir -p /scratch/.udocker
          cp -R "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}"/* /scratch/.udocker/ || \
            { echo "Failed to copy udocker cache to /scratch/.udocker; will pull layers instead"; }
        fi
        

        # Find BAM index files
        TUMOR_BAM_INDEX="${tumor_aligned_bam}.bai"

        if [ ! -f "$TUMOR_BAM_INDEX" ]; then
          echo "Error: Tumor BAM index file not found at $TUMOR_BAM_INDEX"
          exit 1
        fi

        # Copy tumor BAM files to /scratch
        echo "Copying tumor BAM files to /scratch..."
        copy_with_progress "/scratch" "$tumor_aligned_bam" "$TUMOR_BAM_INDEX"
        LOCAL_TUMOR_BAM="/scratch/$(basename "$tumor_aligned_bam")"
        LOCAL_TUMOR_BAM_INDEX="/scratch/$(basename "$TUMOR_BAM_INDEX")"

        # Handle normal BAM files if provided
        LOCAL_NORMAL_BAM=""
        LOCAL_NORMAL_BAM_INDEX=""
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          NORMAL_BAM_INDEX="${normal_aligned_bam}.bai"
          
          if [ ! -f "$NORMAL_BAM_INDEX" ]; then
            echo "Error: Normal BAM index file not found at $NORMAL_BAM_INDEX"
            exit 1
          fi

          echo "Copying normal BAM files to /scratch..."
          copy_with_progress "/scratch" "$normal_aligned_bam" "$NORMAL_BAM_INDEX"
          LOCAL_NORMAL_BAM="/scratch/$(basename "$normal_aligned_bam")"
          LOCAL_NORMAL_BAM_INDEX="/scratch/$(basename "$NORMAL_BAM_INDEX")"
        fi

        # Run split_contigs
        echo "================================================"
        echo "ðŸš€ STARTING SPLIT CONTIGS ANALYSIS"
        echo "================================================"
        echo "ðŸ“… Server Time: $(date)"
        echo "ðŸ“ Input Files:"
        echo "  - Reference Index: $(basename "$LOCAL_REF_INDEX") ($(format_file_size "$LOCAL_REF_INDEX"))"
        echo "âš™ï¸  Configuration:"
        echo "  - Chunk Size: 75,000,000"
        echo "  - Threads: 2"
        echo "================================================"
        
        # Record start time
        SPLIT_START_TIME=$(date +%s)
        
        jq -n \
          --arg ref_fasta_index "$LOCAL_REF_INDEX" \
          --argjson chunk_size 75000000 \
          --argjson threads 2 \
          '{
            "split_contigs.ref_fasta_index": $ref_fasta_index,
            "split_contigs.chunk_size": $chunk_size,
            "split_contigs.threads": $threads
          }' > /scratch/inputs_split_contigs.json
        
        # Capture miniwdl output and extract contigs array
        MINIWDL_OUTPUT=$(miniwdl run \
          "${TASK_DIR}/HiFi-somatic-WDL-0.9.2/tasks/common.wdl" \
          --task split_contigs \
          --dir /scratch \
          --runtime-cpu-max=2 \
          --runtime-memory-max=4G \
          -i /scratch/inputs_split_contigs.json 2>/dev/null)
        
        # Post-execution logging for Split Contigs
        SPLIT_END_TIME=$(date +%s)
        SPLIT_DURATION=$((SPLIT_END_TIME - SPLIT_START_TIME))
        SPLIT_DURATION_HOUR=$((SPLIT_DURATION / 3600))
        SPLIT_DURATION_MIN=$(((SPLIT_DURATION % 3600) / 60))
        SPLIT_DURATION_SEC=$((SPLIT_DURATION % 60))
        
        echo "================================================"
        echo "âœ… SPLIT CONTIGS ANALYSIS COMPLETED SUCCESSFULLY"
        echo "================================================"
        echo "â±ï¸  Execution Time: ${SPLIT_DURATION_HOUR}h ${SPLIT_DURATION_MIN}m ${SPLIT_DURATION_SEC}s"
        echo "ðŸ“ Output Files:"
        echo "  - Contigs split into chunks"
        echo "================================================"
        
        # Extract contigs array from miniwdl output using jq
        CONTIGS_SPLIT_JSON=$(echo "$MINIWDL_OUTPUT" | jq -r '.outputs."split_contigs.contigs"')

        # Run deepsomatic

        # Create inputs JSON file using jq to properly handle the contigs array
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          # Include normal sample parameters
          jq -n \
            --arg tumor_bam "$LOCAL_TUMOR_BAM" \
            --arg tumor_bam_index "$LOCAL_TUMOR_BAM_INDEX" \
            --arg normal_bam "$LOCAL_NORMAL_BAM" \
            --arg normal_bam_index "$LOCAL_NORMAL_BAM_INDEX" \
            --arg ref_fasta "$LOCAL_REF_FASTA" \
            --arg ref_fasta_index "$LOCAL_REF_INDEX" \
            --argjson contigs "$CONTIGS_SPLIT_JSON" \
            --argjson threads "$AGENT_CPU_CORES" \
            --arg tumor_pname "$tumor_sample_name" \
            --arg normal_pname "$normal_sample_name" \
            '{
              "run_deepsomatic.tumor_bam": $tumor_bam,
              "run_deepsomatic.tumor_bam_index": $tumor_bam_index,
              "run_deepsomatic.normal_bam": $normal_bam,
              "run_deepsomatic.normal_bam_index": $normal_bam_index,
              "run_deepsomatic.ref_fasta": $ref_fasta,
              "run_deepsomatic.ref_fasta_index": $ref_fasta_index,
              "run_deepsomatic.contigs": $contigs,
              "run_deepsomatic.threads": $threads,
              "run_deepsomatic.tumor_pname": $tumor_pname,
              "run_deepsomatic.normal_pname": $normal_pname
            }' > /scratch/inputs_deepsomatic.json
        else
          # Exclude normal sample parameters
          jq -n \
            --arg tumor_bam "$LOCAL_TUMOR_BAM" \
            --arg tumor_bam_index "$LOCAL_TUMOR_BAM_INDEX" \
            --arg ref_fasta "$LOCAL_REF_FASTA" \
            --arg ref_fasta_index "$LOCAL_REF_INDEX" \
            --argjson contigs "$CONTIGS_SPLIT_JSON" \
            --argjson threads "$AGENT_CPU_CORES" \
            --arg tumor_pname "$tumor_sample_name" \
            '{
              "run_deepsomatic.tumor_bam": $tumor_bam,
              "run_deepsomatic.tumor_bam_index": $tumor_bam_index,
              "run_deepsomatic.ref_fasta": $ref_fasta,
              "run_deepsomatic.ref_fasta_index": $ref_fasta_index,
              "run_deepsomatic.contigs": $contigs,
              "run_deepsomatic.threads": $threads,
              "run_deepsomatic.tumor_pname": $tumor_pname
            }' > /scratch/inputs_deepsomatic.json
        fi
        # Run deepsomatic
        echo "================================================"
        echo "ðŸš€ STARTING DEEPSOMATIC ANALYSIS"
        echo "================================================"
        echo "ðŸ“… Server Time: $(date)"
        echo "ðŸ“ Input Files:"
        echo "  - Tumor BAM: $(basename "$LOCAL_TUMOR_BAM") ($(format_file_size "$LOCAL_TUMOR_BAM"))"
        echo "  - Tumor BAM Index: $(basename "$LOCAL_TUMOR_BAM_INDEX") ($(format_file_size "$LOCAL_TUMOR_BAM_INDEX"))"
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          echo "  - Normal BAM: $(basename "$LOCAL_NORMAL_BAM") ($(format_file_size "$LOCAL_NORMAL_BAM"))"
          echo "  - Normal BAM Index: $(basename "$LOCAL_NORMAL_BAM_INDEX") ($(format_file_size "$LOCAL_NORMAL_BAM_INDEX"))"
        fi
        echo "  - Reference FASTA: $(basename "$LOCAL_REF_FASTA") ($(format_file_size "$LOCAL_REF_FASTA"))"
        echo "  - Reference Index: $(basename "$LOCAL_REF_INDEX") ($(format_file_size "$LOCAL_REF_INDEX"))"
        echo "âš™ï¸  Configuration:"
        echo "  - Tumor Sample: $tumor_sample_name"
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          echo "  - Normal Sample: $normal_sample_name"
        fi
        echo "  - Threads: $AGENT_CPU_CORES"
        echo "================================================"
        
        # Record start time
        DEEPSOMATIC_START_TIME=$(date +%s)
        
        # Run miniwdl
        set +e
        MINIWDL_OUTPUT=$(miniwdl run \
          "${TASK_DIR}/HiFi-somatic-WDL-0.9.2/tasks/deepsomatic.wdl" \
          --dir /scratch \
          --runtime-cpu-max=$AGENT_CPU_CORES \
          --runtime-memory-max=${AGENT_MEMORY_GB}G \
          -i /scratch/inputs_deepsomatic.json 2>/dev/null)
        MINIWDL_EXIT_CODE=$?
        set -e

        if [ $MINIWDL_EXIT_CODE -ne 0 ]; then
          echo "MiniWDL run failed with exit code $MINIWDL_EXIT_CODE"
          handle_miniwdl_failure $MINIWDL_EXIT_CODE
        fi

        # Post-execution logging for DeepSomatic
        DEEPSOMATIC_END_TIME=$(date +%s)
        DEEPSOMATIC_DURATION=$((DEEPSOMATIC_END_TIME - DEEPSOMATIC_START_TIME))
        DEEPSOMATIC_DURATION_HOUR=$((DEEPSOMATIC_DURATION / 3600))
        DEEPSOMATIC_DURATION_MIN=$(((DEEPSOMATIC_DURATION % 3600) / 60))
        DEEPSOMATIC_DURATION_SEC=$((DEEPSOMATIC_DURATION % 60))
        
        echo "================================================"
        echo "âœ… DEEPSOMATIC ANALYSIS COMPLETED SUCCESSFULLY"
        echo "================================================"
        echo "â±ï¸  Execution Time: ${DEEPSOMATIC_DURATION_HOUR}h ${DEEPSOMATIC_DURATION_MIN}m ${DEEPSOMATIC_DURATION_SEC}s"
        echo "ðŸ“ Output Files:"
        
        # Extract and report output file sizes from miniwdl output
        echo "$MINIWDL_OUTPUT" | jq -r '.outputs | to_entries[] | select(.key | startswith("run_deepsomatic")) | .value' | while read -r output_file; do
          if [ -f "$output_file" ]; then
            echo "  - $(basename "$output_file") ($(format_file_size "$output_file"))"
          fi
        done
        echo "================================================"

        # Extract the deepsomatic VCF path from miniwdl output
        LOCAL_DEEPSOMATIC_VCF=$(echo "$MINIWDL_OUTPUT" | jq -r '.outputs."run_deepsomatic.deepsomatic_vcf"')
        LOCAL_DEEPSOMATIC_GVCF=$(echo "$MINIWDL_OUTPUT" | jq -r '.outputs."run_deepsomatic.deepsomatic_gvcf"')
        LOCAL_CLAIR3_TUMOR_VCF=$(echo "$MINIWDL_OUTPUT" | jq -r '.outputs."run_deepsomatic.clair3_tumor_vcf"')
        
        # Extract normal Clair3 VCF path if normal sample is provided
        LOCAL_CLAIR3_NORMAL_VCF=""
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          LOCAL_CLAIR3_NORMAL_VCF=$(echo "$MINIWDL_OUTPUT" | jq -r '.outputs."run_deepsomatic.clair3_normal_vcf"')
        fi

        # Copy DeepSomatic outputs with standardized naming
        echo "Copying DeepSomatic outputs with standardized naming..."
        DEEPSOMATIC_OUTPUT_FILES=()
        if [ -f "$LOCAL_DEEPSOMATIC_VCF" ]; then
          DEEPSOMATIC_OUTPUT_FILES+=("$LOCAL_DEEPSOMATIC_VCF")
        fi
        if [ -f "${LOCAL_DEEPSOMATIC_VCF}.tbi" ]; then
          DEEPSOMATIC_OUTPUT_FILES+=("${LOCAL_DEEPSOMATIC_VCF}.tbi")
        fi
        if [ -f "$LOCAL_DEEPSOMATIC_GVCF" ]; then
          DEEPSOMATIC_OUTPUT_FILES+=("$LOCAL_DEEPSOMATIC_GVCF")
        fi
        if [ -f "${LOCAL_DEEPSOMATIC_GVCF}.tbi" ]; then
          DEEPSOMATIC_OUTPUT_FILES+=("${LOCAL_DEEPSOMATIC_GVCF}.tbi")
        fi
        if [ -f "$LOCAL_CLAIR3_TUMOR_VCF" ]; then
          DEEPSOMATIC_OUTPUT_FILES+=("$LOCAL_CLAIR3_TUMOR_VCF")
        fi
        if [ -f "${LOCAL_CLAIR3_TUMOR_VCF}.tbi" ]; then
          DEEPSOMATIC_OUTPUT_FILES+=("${LOCAL_CLAIR3_TUMOR_VCF}.tbi")
        fi
        
        # Copy normal Clair3 VCF with standardized naming if normal sample is provided
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          if [ -f "$LOCAL_CLAIR3_NORMAL_VCF" ]; then
            DEEPSOMATIC_OUTPUT_FILES+=("$LOCAL_CLAIR3_NORMAL_VCF")
          fi
          if [ -f "${LOCAL_CLAIR3_NORMAL_VCF}.tbi" ]; then
            DEEPSOMATIC_OUTPUT_FILES+=("${LOCAL_CLAIR3_NORMAL_VCF}.tbi")
          fi
        fi
        
        if [ ${#DEEPSOMATIC_OUTPUT_FILES[@]} -gt 0 ]; then
          copy_with_progress "$output_folder" "${DEEPSOMATIC_OUTPUT_FILES[@]}"
        fi

        # Run mutational pattern analysis
        echo "================================================"
        echo "ðŸš€ STARTING MUTATIONAL PATTERN ANALYSIS"
        echo "================================================"
        echo "ðŸ“… Server Time: $(date)"
        echo "ðŸ“ Input Files:"
        echo "  - DeepSomatic VCF: $(basename "$LOCAL_DEEPSOMATIC_VCF") ($(format_file_size "$LOCAL_DEEPSOMATIC_VCF"))"
        echo "âš™ï¸  Configuration:"
        echo "  - Sample: $tumor_sample_name"
        echo "  - Max Delta: 0.004"
        echo "  - Threads: $AGENT_CPU_CORES"
        echo "================================================"
        
        # Record start time
        MUTATIONAL_START_TIME=$(date +%s)
        
        jq -n \
          --arg vcf "$LOCAL_DEEPSOMATIC_VCF" \
          --arg pname "$tumor_sample_name" \
          --argjson max_delta 0.004 \
          --argjson threads "$AGENT_CPU_CORES" \
          '{
            "mutationalpattern.vcf": $vcf,
            "mutationalpattern.pname": $pname,
            "mutationalpattern.max_delta": $max_delta,
            "mutationalpattern.threads": $threads
          }' > /scratch/inputs_mutationalpattern.json

        # Run miniwdl
        set +e
        MUTATIONAL_MINIWDL_OUTPUT=$(miniwdl run \
          "${TASK_DIR}/HiFi-somatic-WDL-0.9.2/tasks/common.wdl" \
          --task mutationalpattern \
          --dir /scratch \
          --runtime-cpu-max=$AGENT_CPU_CORES \
          --runtime-memory-max=${AGENT_MEMORY_GB}G \
          -i /scratch/inputs_mutationalpattern.json 2>/dev/null)
        MINIWDL_EXIT_CODE=$?
        set -e

        if [ $MINIWDL_EXIT_CODE -ne 0 ]; then
          echo "MiniWDL run failed with exit code $MINIWDL_EXIT_CODE"
          handle_miniwdl_failure $MINIWDL_EXIT_CODE
        fi

        # Post-execution logging for Mutational Pattern
        MUTATIONAL_END_TIME=$(date +%s)
        MUTATIONAL_DURATION=$((MUTATIONAL_END_TIME - MUTATIONAL_START_TIME))
        MUTATIONAL_DURATION_HOUR=$((MUTATIONAL_DURATION / 3600))
        MUTATIONAL_DURATION_MIN=$(((MUTATIONAL_DURATION % 3600) / 60))
        MUTATIONAL_DURATION_SEC=$((MUTATIONAL_DURATION % 60))
        
        echo "================================================"
        echo "âœ… MUTATIONAL PATTERN ANALYSIS COMPLETED SUCCESSFULLY"
        echo "================================================"
        echo "â±ï¸  Execution Time: ${MUTATIONAL_DURATION_HOUR}h ${MUTATIONAL_DURATION_MIN}m ${MUTATIONAL_DURATION_SEC}s"
        echo "ðŸ“ Output Files:"
        
        # Extract and report output file sizes from miniwdl output
        echo "$MUTATIONAL_MINIWDL_OUTPUT" | jq -r '.outputs | to_entries[] | select(.key | startswith("mutationalpattern")) | .value' | while read -r output_file; do
          if [ -f "$output_file" ]; then
            echo "  - $(basename "$output_file") ($(format_file_size "$output_file"))"
          fi
        done
        echo "================================================"

        bash "$TASK_DIR/utils/process-outputs.sh" "$output_folder" "${tumor_sample_name}" > /dev/null 2>&1 

        # Copy udocker cache to output folder
        if [ "$cache_udocker_images" = true ] && [ ! -d "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}" ]; then
          mkdir -p "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}"
          cp -r /scratch/.udocker/layers /scratch/.udocker/repos "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}" 2>/dev/null || true
        fi

        echo "*************************"
        echo "DeepSomatic completed successfully"
        echo "Output files copied to: $output_folder"
        echo "*************************"
