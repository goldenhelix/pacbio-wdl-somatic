name: DeepSomatic
description: Call variants from PacBio HiFi aligned BAM using DeepSomatic.
auto_generate_session_for_account: "{workspaceBot}"

agent_requirements:
  cpu_cores: 48
  memory_gb: 96

parameters:
  - name: tumor_sample_name
    label: Sample Name (tumor)
    type: string

  - name: tumor_aligned_bam
    label: Tumor Aligned BAM
    type: file
    pattern_match:
      - '*.bam'
    
  - name: normal_aligned_bam
    label: Normal Aligned BAM (Optional)
    type: file
    pattern_match:
      - '*.bam'
    optional: true

  - name: normal_sample_name
    label: Normal Sample Name (Optional)
    type: string
    optional: true

  - name: output_folder
    label: Output Folder
    type: directory
    supports_location_mode: 'no_append'
  
  - name: cache_udocker_images
    label: Cache Udocker Image
    type: boolean
    value: true

steps:
  - name: deepsomatic
    type: cmd
    description: Call variants from PacBio HiFi aligned BAM using DeepSomatic.
    args:
      - |- # shell
        set -eu pipefail

        echo "*************************"
        echo "Starting DeepSomatic Task"
        echo "Space on agent: $(df -h /scratch | tail -n 1 | awk '{print $4}')"
        echo "Input Parameters:"
        echo "  - tumor_sample_name: $tumor_sample_name"
        echo "  - tumor_aligned_bam: $tumor_aligned_bam"
        echo "  - normal_aligned_bam: $normal_aligned_bam"
        echo "  - normal_sample_name: $normal_sample_name"
        echo "  - output_folder: $output_folder"
        echo "  - cache_udocker_images: $cache_udocker_images"
        echo "*************************"

        # Check if output files already exist
        echo "Checking if output files already exist..."
        OUTPUT_FILES_EXIST=true

        # Check if normal sample parameters are provided
        NORMAL_SAMPLE_PROVIDED=false
        if [ -n "$normal_sample_name" ] && [ -n "$normal_aligned_bam" ]; then
          NORMAL_SAMPLE_PROVIDED=true
          
          # Check if normal sample name matches the matched normal sample in sample catalog
          CATALOG_NORMAL_SAMPLE=$(gautil client catalog-export SampleCatalog Sample:eq:"$tumor_sample_name" --fields="NormalSample" | tail -n 1 | tr -d '\r\n\t ')
          
          if [ -n "$CATALOG_NORMAL_SAMPLE" ]; then
            if [ "$normal_sample_name" != "$CATALOG_NORMAL_SAMPLE" ]; then
              echo "Warning: Normal sample name '$normal_sample_name' does not match the matched normal sample '$CATALOG_NORMAL_SAMPLE' in the sample catalog for tumor sample '$tumor_sample_name'"
            fi
          fi
        elif [ -n "$normal_sample_name" ] || [ -n "$normal_aligned_bam" ]; then
          echo "Warning: Only one of normal sample name or normal BAM file is provided. Normal sample will be ignored."
        fi
        
        # Check for DeepSomatic output files with standardized naming
        DEEPSOMATIC_VCF_FILES=$(find "$output_folder" -name "${tumor_sample_name}.deepsomatic.vcf.gz" 2>/dev/null | wc -l)
        DEEPSOMATIC_GVCF_FILES=$(find "$output_folder" -name "${tumor_sample_name}.deepsomatic.g.vcf.gz" 2>/dev/null | wc -l)
        CLAIR3_TUMOR_VCF_FILES=$(find "$output_folder" -name "${tumor_sample_name}.clair3.small_variants.correct_ref.vcf.gz" 2>/dev/null | wc -l)
        
        # Check for normal Clair3 VCF files if normal sample is provided
        CLAIR3_NORMAL_VCF_FILES=0
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          CLAIR3_NORMAL_VCF_FILES=$(find "$output_folder" -name "${normal_sample_name}.clair3.small_variants.correct_ref.vcf.gz" 2>/dev/null | wc -l)
        fi
        
        # Check for mutational pattern output files based on actual WDL outputs
        MUTATIONAL_PROFILE_FILES=$(find "$output_folder" -name "*.mutation_profile.pdf" 2>/dev/null | wc -l)
        MUTATIONAL_SIG_FILES=$(find "$output_folder" -name "*.mut_sigs.tsv" 2>/dev/null | wc -l)
        MUTATIONAL_BOOTSTRAP_FILES=$(find "$output_folder" -name "*.mut_sigs_bootstrapped.tsv" 2>/dev/null | wc -l)
        MUTATIONAL_RECON_FILES=$(find "$output_folder" -name "*.reconstructed_sigs.tsv" 2>/dev/null | wc -l)
        MUTATIONAL_OCCURRENCE_FILES=$(find "$output_folder" -name "*.type_occurences.tsv" 2>/dev/null | wc -l)
        
        echo "  - Found $DEEPSOMATIC_VCF_FILES DeepSomatic VCF files (${tumor_sample_name}.deepsomatic.vcf.gz)"
        echo "  - Found $DEEPSOMATIC_GVCF_FILES DeepSomatic GVCF files (${tumor_sample_name}.deepsomatic.g.vcf.gz)"
        echo "  - Found $CLAIR3_TUMOR_VCF_FILES Clair3 tumor VCF files (${tumor_sample_name}.clair3.small_variants.correct_ref.vcf.gz)"
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          echo "  - Found $CLAIR3_NORMAL_VCF_FILES Clair3 normal VCF files (${normal_sample_name}.clair3.small_variants.correct_ref.vcf.gz)"
        fi
        echo "  - Found $MUTATIONAL_PROFILE_FILES mutation profile files"
        echo "  - Found $MUTATIONAL_SIG_FILES mutation signature files"
        echo "  - Found $MUTATIONAL_BOOTSTRAP_FILES bootstrap files"
        echo "  - Found $MUTATIONAL_RECON_FILES reconstructed signature files"
        echo "  - Found $MUTATIONAL_OCCURRENCE_FILES occurrence files"
        
        if [ $DEEPSOMATIC_VCF_FILES -eq 0 ] || [ $DEEPSOMATIC_GVCF_FILES -eq 0 ] || [ $CLAIR3_TUMOR_VCF_FILES -eq 0 ] || [ $MUTATIONAL_PROFILE_FILES -eq 0 ] || [ $MUTATIONAL_SIG_FILES -eq 0 ] || [ $MUTATIONAL_BOOTSTRAP_FILES -eq 0 ] || [ $MUTATIONAL_RECON_FILES -eq 0 ] || [ $MUTATIONAL_OCCURRENCE_FILES -eq 0 ]; then
          OUTPUT_FILES_EXIST=false
          echo "  - DeepSomatic output files missing"
        fi
        
        # Check normal Clair3 VCF files if normal sample is provided
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ] && [ $CLAIR3_NORMAL_VCF_FILES -eq 0 ]; then
          OUTPUT_FILES_EXIST=false
          echo "  - Normal Clair3 VCF files missing"
        fi
        
        if [ "$OUTPUT_FILES_EXIST" = true ]; then
          echo "All output files already exist. Skipping task as no-op."
          echo "*************************"
          echo "DeepSomatic Task completed (skipped - outputs exist)"
          echo "*************************"
          exit 0
        else
          echo "Output files missing. Proceeding with analysis..."
        fi

        # Source common utility functions
        source "$TASK_DIR/utils/utils.sh"

        # Set up resources path based on resources_path
        PB_RESOURCES_DIR="${WORKSPACE_DIR}/${RESOURCES_PATH}/hifisomatic_resources"

        # set up env variables for miniwdl
        export MINIWDL__SCHEDULER__CONTAINER_BACKEND=udocker
        export MINIWDL__FILE_IO__ALLOW_ANY_INPUT=true
        export MINIWDL__SCHEDULER__TASK_CONCURRENCY=8
        export UDOCKER_DIR=/scratch/.udocker
        
        # Set up reference files
        REF_FASTA="$PB_RESOURCES_DIR/GCA_000001405.15_GRCh38_no_alt_analysis_set_maskedGRC_exclusions_v2.fasta"
        REF_INDEX="$PB_RESOURCES_DIR/GCA_000001405.15_GRCh38_no_alt_analysis_set_maskedGRC_exclusions_v2.fasta.fai"

        # Verify reference files exist
        if [ ! -f "$REF_FASTA" ]; then
          echo "Error: Reference FASTA file not found at $REF_FASTA"
          exit 1
        fi
        
        if [ ! -f "$REF_INDEX" ]; then
          echo "Error: Reference FASTA index file not found at $REF_INDEX"
          exit 1
        fi

        # Copy reference files to /scratch
        echo "Copying reference files to /scratch..."
        copy_with_progress "/scratch" "$REF_FASTA" "$REF_INDEX"
        LOCAL_REF_FASTA="/scratch/$(basename "$REF_FASTA")"
        LOCAL_REF_INDEX="/scratch/$(basename "$REF_INDEX")"

        # Pull udocker layers from cache if requested
        if [ -d "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}" ] && [ "$cache_udocker_images" = true ]; then
          echo "Pulling udocker image from cache..."
          mkdir -p /scratch/.udocker
          cp -R "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}"/* /scratch/.udocker/ || \
            { echo "Failed to copy udocker cache to /scratch/.udocker; will pull layers instead"; }
        fi
        

        # Find BAM index files
        TUMOR_BAM_INDEX="${tumor_aligned_bam}.bai"

        if [ ! -f "$TUMOR_BAM_INDEX" ]; then
          echo "Error: Tumor BAM index file not found at $TUMOR_BAM_INDEX"
          exit 1
        fi

        # Copy tumor BAM files to /scratch
        echo "Copying tumor BAM files to /scratch..."
        copy_with_progress "/scratch" "$tumor_aligned_bam" "$TUMOR_BAM_INDEX"
        LOCAL_TUMOR_BAM="/scratch/$(basename "$tumor_aligned_bam")"
        LOCAL_TUMOR_BAM_INDEX="/scratch/$(basename "$TUMOR_BAM_INDEX")"

        # Handle normal BAM files if provided
        LOCAL_NORMAL_BAM=""
        LOCAL_NORMAL_BAM_INDEX=""
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          NORMAL_BAM_INDEX="${normal_aligned_bam}.bai"
          
          if [ ! -f "$NORMAL_BAM_INDEX" ]; then
            echo "Error: Normal BAM index file not found at $NORMAL_BAM_INDEX"
            exit 1
          fi

          echo "Copying normal BAM files to /scratch..."
          copy_with_progress "/scratch" "$normal_aligned_bam" "$NORMAL_BAM_INDEX"
          LOCAL_NORMAL_BAM="/scratch/$(basename "$normal_aligned_bam")"
          LOCAL_NORMAL_BAM_INDEX="/scratch/$(basename "$NORMAL_BAM_INDEX")"
        fi

        # Run split_contigs
        echo "================================================"
        echo "ðŸš€ STARTING SPLIT CONTIGS ANALYSIS"
        echo "================================================"
        echo "ðŸ“… Server Time: $(date)"
        echo "ðŸ“ Input Files:"
        echo "  - Reference Index: $(basename "$LOCAL_REF_INDEX") ($(format_file_size "$LOCAL_REF_INDEX"))"
        echo "âš™ï¸  Configuration:"
        echo "  - Chunk Size: 75,000,000"
        echo "  - Threads: 2"
        echo "================================================"
        
        # Record start time
        SPLIT_START_TIME=$(date +%s)
        
        jq -n \
          --arg ref_fasta_index "$LOCAL_REF_INDEX" \
          --argjson chunk_size 75000000 \
          --argjson threads 2 \
          '{
            "split_contigs.ref_fasta_index": $ref_fasta_index,
            "split_contigs.chunk_size": $chunk_size,
            "split_contigs.threads": $threads
          }' > /scratch/inputs_split_contigs.json
        
        # Capture miniwdl output and extract contigs array
        MINIWDL_OUTPUT=$(miniwdl run \
          "${TASK_DIR}/HiFi-somatic-WDL-0.9.2/tasks/common.wdl" \
          --task split_contigs \
          --dir /scratch \
          --runtime-cpu-max=2 \
          --runtime-memory-max=4G \
          -i /scratch/inputs_split_contigs.json 2>/dev/null)
        
        # Post-execution logging for Split Contigs
        SPLIT_END_TIME=$(date +%s)
        SPLIT_DURATION=$((SPLIT_END_TIME - SPLIT_START_TIME))
        SPLIT_DURATION_HOUR=$((SPLIT_DURATION / 3600))
        SPLIT_DURATION_MIN=$(((SPLIT_DURATION % 3600) / 60))
        SPLIT_DURATION_SEC=$((SPLIT_DURATION % 60))
        
        echo "================================================"
        echo "âœ… SPLIT CONTIGS ANALYSIS COMPLETED SUCCESSFULLY"
        echo "================================================"
        echo "â±ï¸  Execution Time: ${SPLIT_DURATION_HOUR}h ${SPLIT_DURATION_MIN}m ${SPLIT_DURATION_SEC}s"
        echo "ðŸ“ Output Files:"
        echo "  - Contigs split into chunks"
        echo "================================================"
        
        # Extract contigs array from miniwdl output using jq
        CONTIGS_SPLIT_JSON=$(echo "$MINIWDL_OUTPUT" | jq -r '.outputs."split_contigs.contigs"')

        # Run deepsomatic

        # Create inputs JSON file using jq to properly handle the contigs array
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          # Include normal sample parameters
          jq -n \
            --arg tumor_bam "$LOCAL_TUMOR_BAM" \
            --arg tumor_bam_index "$LOCAL_TUMOR_BAM_INDEX" \
            --arg normal_bam "$LOCAL_NORMAL_BAM" \
            --arg normal_bam_index "$LOCAL_NORMAL_BAM_INDEX" \
            --arg ref_fasta "$LOCAL_REF_FASTA" \
            --arg ref_fasta_index "$LOCAL_REF_INDEX" \
            --argjson contigs "$CONTIGS_SPLIT_JSON" \
            --argjson threads "$AGENT_CPU_CORES" \
            --arg tumor_pname "$tumor_sample_name" \
            --arg normal_pname "$normal_sample_name" \
            '{
              "run_deepsomatic.tumor_bam": $tumor_bam,
              "run_deepsomatic.tumor_bam_index": $tumor_bam_index,
              "run_deepsomatic.normal_bam": $normal_bam,
              "run_deepsomatic.normal_bam_index": $normal_bam_index,
              "run_deepsomatic.ref_fasta": $ref_fasta,
              "run_deepsomatic.ref_fasta_index": $ref_fasta_index,
              "run_deepsomatic.contigs": $contigs,
              "run_deepsomatic.threads": $threads,
              "run_deepsomatic.tumor_pname": $tumor_pname,
              "run_deepsomatic.normal_pname": $normal_pname
            }' > /scratch/inputs_deepsomatic.json
        else
          # Exclude normal sample parameters
          jq -n \
            --arg tumor_bam "$LOCAL_TUMOR_BAM" \
            --arg tumor_bam_index "$LOCAL_TUMOR_BAM_INDEX" \
            --arg ref_fasta "$LOCAL_REF_FASTA" \
            --arg ref_fasta_index "$LOCAL_REF_INDEX" \
            --argjson contigs "$CONTIGS_SPLIT_JSON" \
            --argjson threads "$AGENT_CPU_CORES" \
            --arg tumor_pname "$tumor_sample_name" \
            '{
              "run_deepsomatic.tumor_bam": $tumor_bam,
              "run_deepsomatic.tumor_bam_index": $tumor_bam_index,
              "run_deepsomatic.ref_fasta": $ref_fasta,
              "run_deepsomatic.ref_fasta_index": $ref_fasta_index,
              "run_deepsomatic.contigs": $contigs,
              "run_deepsomatic.threads": $threads,
              "run_deepsomatic.tumor_pname": $tumor_pname
            }' > /scratch/inputs_deepsomatic.json
        fi
        # Run deepsomatic
        echo "================================================"
        echo "ðŸš€ STARTING DEEPSOMATIC ANALYSIS"
        echo "================================================"
        echo "ðŸ“… Server Time: $(date)"
        echo "ðŸ“ Input Files:"
        echo "  - Tumor BAM: $(basename "$LOCAL_TUMOR_BAM") ($(format_file_size "$LOCAL_TUMOR_BAM"))"
        echo "  - Tumor BAM Index: $(basename "$LOCAL_TUMOR_BAM_INDEX") ($(format_file_size "$LOCAL_TUMOR_BAM_INDEX"))"
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          echo "  - Normal BAM: $(basename "$LOCAL_NORMAL_BAM") ($(format_file_size "$LOCAL_NORMAL_BAM"))"
          echo "  - Normal BAM Index: $(basename "$LOCAL_NORMAL_BAM_INDEX") ($(format_file_size "$LOCAL_NORMAL_BAM_INDEX"))"
        fi
        echo "  - Reference FASTA: $(basename "$LOCAL_REF_FASTA") ($(format_file_size "$LOCAL_REF_FASTA"))"
        echo "  - Reference Index: $(basename "$LOCAL_REF_INDEX") ($(format_file_size "$LOCAL_REF_INDEX"))"
        echo "âš™ï¸  Configuration:"
        echo "  - Tumor Sample: $tumor_sample_name"
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          echo "  - Normal Sample: $normal_sample_name"
        fi
        echo "  - Threads: $AGENT_CPU_CORES"
        echo "================================================"
        
        # Record start time
        DEEPSOMATIC_START_TIME=$(date +%s)
        
        # Run miniwdl
        set +e
        MINIWDL_OUTPUT=$(miniwdl run \
          "${TASK_DIR}/HiFi-somatic-WDL-0.9.2/tasks/deepsomatic.wdl" \
          --dir /scratch \
          --runtime-cpu-max=$AGENT_CPU_CORES \
          --runtime-memory-max=${AGENT_MEMORY_GB}G \
          -i /scratch/inputs_deepsomatic.json 2>/dev/null)
        MINIWDL_EXIT_CODE=$?
        set -e

        if [ $MINIWDL_EXIT_CODE -ne 0 ]; then
          echo "MiniWDL run failed with exit code $MINIWDL_EXIT_CODE"
          handle_miniwdl_failure $MINIWDL_EXIT_CODE
        fi

        # Post-execution logging for DeepSomatic
        DEEPSOMATIC_END_TIME=$(date +%s)
        DEEPSOMATIC_DURATION=$((DEEPSOMATIC_END_TIME - DEEPSOMATIC_START_TIME))
        DEEPSOMATIC_DURATION_HOUR=$((DEEPSOMATIC_DURATION / 3600))
        DEEPSOMATIC_DURATION_MIN=$(((DEEPSOMATIC_DURATION % 3600) / 60))
        DEEPSOMATIC_DURATION_SEC=$((DEEPSOMATIC_DURATION % 60))
        
        echo "================================================"
        echo "âœ… DEEPSOMATIC ANALYSIS COMPLETED SUCCESSFULLY"
        echo "================================================"
        echo "â±ï¸  Execution Time: ${DEEPSOMATIC_DURATION_HOUR}h ${DEEPSOMATIC_DURATION_MIN}m ${DEEPSOMATIC_DURATION_SEC}s"
        echo "ðŸ“ Output Files:"
        
        # Extract and report output file sizes from miniwdl output
        echo "$MINIWDL_OUTPUT" | jq -r '.outputs | to_entries[] | select(.key | startswith("run_deepsomatic")) | .value' | while read -r output_file; do
          if [ -f "$output_file" ]; then
            echo "  - $(basename "$output_file") ($(format_file_size "$output_file"))"
          fi
        done
        echo "================================================"

        # Extract the deepsomatic VCF path from miniwdl output
        LOCAL_DEEPSOMATIC_VCF=$(echo "$MINIWDL_OUTPUT" | jq -r '.outputs."run_deepsomatic.deepsomatic_vcf"')
        LOCAL_DEEPSOMATIC_GVCF=$(echo "$MINIWDL_OUTPUT" | jq -r '.outputs."run_deepsomatic.deepsomatic_gvcf"')
        LOCAL_CLAIR3_TUMOR_VCF=$(echo "$MINIWDL_OUTPUT" | jq -r '.outputs."run_deepsomatic.clair3_tumor_vcf"')
        
        # Extract normal Clair3 VCF path if normal sample is provided
        LOCAL_CLAIR3_NORMAL_VCF=""
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          LOCAL_CLAIR3_NORMAL_VCF=$(echo "$MINIWDL_OUTPUT" | jq -r '.outputs."run_deepsomatic.clair3_normal_vcf"')
        fi

        # Rename deepsomatic files to use standardized naming (underscore to dot)
        echo "Renaming deepsomatic files to standardized naming..."
        
        # Rename deepsomatic.vcf.gz
        if [ -f "$LOCAL_DEEPSOMATIC_VCF" ]; then
          LOCAL_DEEPSOMATIC_VCF_DIR=$(dirname "$LOCAL_DEEPSOMATIC_VCF")
          LOCAL_DEEPSOMATIC_VCF_BASE=$(basename "$LOCAL_DEEPSOMATIC_VCF")
          NEW_LOCAL_DEEPSOMATIC_VCF="${LOCAL_DEEPSOMATIC_VCF_DIR}/${tumor_sample_name}.deepsomatic.vcf.gz"
          
          if [ "$LOCAL_DEEPSOMATIC_VCF_BASE" != "${tumor_sample_name}.deepsomatic.vcf.gz" ]; then
            echo "  - Renaming: $LOCAL_DEEPSOMATIC_VCF_BASE â†’ ${tumor_sample_name}.deepsomatic.vcf.gz"
            mv "$LOCAL_DEEPSOMATIC_VCF" "$NEW_LOCAL_DEEPSOMATIC_VCF"
            LOCAL_DEEPSOMATIC_VCF="$NEW_LOCAL_DEEPSOMATIC_VCF"
          fi
        fi
        
        # Rename deepsomatic.g.vcf.gz
        if [ -f "$LOCAL_DEEPSOMATIC_GVCF" ]; then
          LOCAL_DEEPSOMATIC_GVCF_DIR=$(dirname "$LOCAL_DEEPSOMATIC_GVCF")
          LOCAL_DEEPSOMATIC_GVCF_BASE=$(basename "$LOCAL_DEEPSOMATIC_GVCF")
          NEW_LOCAL_DEEPSOMATIC_GVCF="${LOCAL_DEEPSOMATIC_GVCF_DIR}/${tumor_sample_name}.deepsomatic.g.vcf.gz"
          
          if [ "$LOCAL_DEEPSOMATIC_GVCF_BASE" != "${tumor_sample_name}.deepsomatic.g.vcf.gz" ]; then
            echo "  - Renaming: $LOCAL_DEEPSOMATIC_GVCF_BASE â†’ ${tumor_sample_name}.deepsomatic.g.vcf.gz"
            mv "$LOCAL_DEEPSOMATIC_GVCF" "$NEW_LOCAL_DEEPSOMATIC_GVCF"
            LOCAL_DEEPSOMATIC_GVCF="$NEW_LOCAL_DEEPSOMATIC_GVCF"
          fi
        fi

        # Copy DeepSomatic outputs with standardized naming
        echo "Copying DeepSomatic outputs with standardized naming..."
        DEEPSOMATIC_OUTPUT_FILES=()
        
        # Function to add VCF file and create/index if needed
        add_vcf_with_index() {
          local vcf_file="$1"
          if [ -f "$vcf_file" ]; then
            echo "  - Adding VCF: $(basename "$vcf_file")"
            DEEPSOMATIC_OUTPUT_FILES+=("$vcf_file")
            
            # Check if index exists, create if needed
            if [ ! -f "${vcf_file}.tbi" ]; then
              echo "    Index missing, creating: $(basename "${vcf_file}.tbi")"
              tabix -f -p vcf "$vcf_file" || { echo "    âš ï¸  Warning: Failed to create index for $(basename "$vcf_file")"; if [ ! -f "${vcf_file}.tbi" ]; then echo "    Index file does not exist"; else echo "    Index file exists, continuing..."; fi; }
            fi
            
            # Only add .tbi to list if it actually exists
            if [ -f "${vcf_file}.tbi" ]; then
              echo "    âœ“ Adding index: $(basename "${vcf_file}.tbi")"
              DEEPSOMATIC_OUTPUT_FILES+=("${vcf_file}.tbi")
            else
              echo "    âœ— Index file not available"
            fi
          fi
        }
        
        # Add DeepSomatic VCF with index
        add_vcf_with_index "$LOCAL_DEEPSOMATIC_VCF"
        
        # Add DeepSomatic GVCF with index
        add_vcf_with_index "$LOCAL_DEEPSOMATIC_GVCF"
        
        # Add Clair3 tumor VCF with index
        add_vcf_with_index "$LOCAL_CLAIR3_TUMOR_VCF"
        
        # Copy normal Clair3 VCF with standardized naming if normal sample is provided
        if [ "$NORMAL_SAMPLE_PROVIDED" = true ]; then
          add_vcf_with_index "$LOCAL_CLAIR3_NORMAL_VCF"
        fi
        
        if [ ${#DEEPSOMATIC_OUTPUT_FILES[@]} -gt 0 ]; then
          copy_with_progress "$output_folder" "${DEEPSOMATIC_OUTPUT_FILES[@]}"
        fi

        # Run mutational pattern analysis
        echo "================================================"
        echo "ðŸš€ STARTING MUTATIONAL PATTERN ANALYSIS"
        echo "================================================"
        echo "ðŸ“… Server Time: $(date)"
        echo "ðŸ“ Input Files:"
        echo "  - DeepSomatic VCF: $(basename "$LOCAL_DEEPSOMATIC_VCF") ($(format_file_size "$LOCAL_DEEPSOMATIC_VCF"))"
        echo "âš™ï¸  Configuration:"
        echo "  - Sample: $tumor_sample_name"
        echo "  - Max Delta: 0.004"
        echo "  - Threads: $AGENT_CPU_CORES"
        echo "================================================"
        
        # Record start time
        MUTATIONAL_START_TIME=$(date +%s)
        
        jq -n \
          --arg vcf "$LOCAL_DEEPSOMATIC_VCF" \
          --arg pname "$tumor_sample_name" \
          --argjson max_delta 0.004 \
          --argjson threads "$AGENT_CPU_CORES" \
          '{
            "mutationalpattern.vcf": $vcf,
            "mutationalpattern.pname": $pname,
            "mutationalpattern.max_delta": $max_delta,
            "mutationalpattern.threads": $threads
          }' > /scratch/inputs_mutationalpattern.json

        # Run miniwdl
        set +e
        MUTATIONAL_MINIWDL_OUTPUT=$(miniwdl run \
          "${TASK_DIR}/HiFi-somatic-WDL-0.9.2/tasks/common.wdl" \
          --task mutationalpattern \
          --dir /scratch \
          --runtime-cpu-max=$AGENT_CPU_CORES \
          --runtime-memory-max=${AGENT_MEMORY_GB}G \
          -i /scratch/inputs_mutationalpattern.json 2>/dev/null)
        MINIWDL_EXIT_CODE=$?
        set -e

        if [ $MINIWDL_EXIT_CODE -ne 0 ]; then
          echo "MiniWDL run failed with exit code $MINIWDL_EXIT_CODE"
          handle_miniwdl_failure $MINIWDL_EXIT_CODE
        fi

        # Post-execution logging for Mutational Pattern
        MUTATIONAL_END_TIME=$(date +%s)
        MUTATIONAL_DURATION=$((MUTATIONAL_END_TIME - MUTATIONAL_START_TIME))
        MUTATIONAL_DURATION_HOUR=$((MUTATIONAL_DURATION / 3600))
        MUTATIONAL_DURATION_MIN=$(((MUTATIONAL_DURATION % 3600) / 60))
        MUTATIONAL_DURATION_SEC=$((MUTATIONAL_DURATION % 60))
        
        echo "================================================"
        echo "âœ… MUTATIONAL PATTERN ANALYSIS COMPLETED SUCCESSFULLY"
        echo "================================================"
        echo "â±ï¸  Execution Time: ${MUTATIONAL_DURATION_HOUR}h ${MUTATIONAL_DURATION_MIN}m ${MUTATIONAL_DURATION_SEC}s"
        echo "ðŸ“ Output Files:"
        
        # Extract and report output file sizes from miniwdl output
        echo "$MUTATIONAL_MINIWDL_OUTPUT" | jq -r '.outputs | to_entries[] | select(.key | startswith("mutationalpattern")) | .value' | while read -r output_file; do
          if [ -f "$output_file" ]; then
            echo "  - $(basename "$output_file") ($(format_file_size "$output_file"))"
          fi
        done
        echo "================================================"

        # Copy mutational pattern outputs from MiniWDL to output folder
        echo "Copying mutational pattern outputs to $output_folder..."
        if [ -f /scratch/_LAST/outputs.json ]; then
          for key in mutationalpattern.mutsig_tsv mutationalpattern.recon_sig mutationalpattern.occurences_tsv mutationalpattern.mutsig_bootstrap mutationalpattern.mut_profile; do
            src=$(jq -r --arg k "$key" '.[$k]' /scratch/_LAST/outputs.json 2>/dev/null)
            if [ -n "$src" ] && [ "$src" != "null" ] && [ -f "$src" ]; then
              cp "$src" "$output_folder/$(basename "$src")"
              echo "  - Copied: $(basename "$src")"
            fi
          done
          # Copy any additional .tsv from mutsig_output array
          jq -r '.mutationalpattern.mutsig_output[]?' /scratch/_LAST/outputs.json 2>/dev/null | while read -r src; do
            if [ -n "$src" ] && [ -f "$src" ]; then
              cp "$src" "$output_folder/$(basename "$src")"
              echo "  - Copied: $(basename "$src")"
            fi
          done
        else
          echo "Warning: outputs.json not found at /scratch/_LAST/outputs.json"
        fi

        # Update vspipeline_inputs.json with DeepSomatic and Clair3 VCF files
        echo "Updating vspipeline_inputs.json..."
        if command -v python3 &> /dev/null; then
          DEEPSOMATIC_VCF="${output_folder}/${tumor_sample_name}.deepsomatic.vcf.gz"
          if [ -f "$DEEPSOMATIC_VCF" ]; then
            RELATIVE_PATH=$(echo "$DEEPSOMATIC_VCF" | sed "s|^${WORKSPACE_DIR}/||")
            python3 "${TASK_DIR}/vspipeline-resources/vspipeline_utilities.py" update-vspipeline-json \
              --input_dir "$output_folder" \
              --sample "$tumor_sample_name" \
              --file "$RELATIVE_PATH" \
              --file_type multiverse \
              --task_name deepsomatic \
              --scratch_dir /scratch || \
              { echo "Warning: Failed to update vspipeline_inputs.json for DeepSomatic VCF, continuing..."; }
          fi
          CLAIR3_TUMOR_VCF="${output_folder}/${tumor_sample_name}.clair3.small_variants.correct_ref.vcf.gz"
          if [ -f "$CLAIR3_TUMOR_VCF" ]; then
            RELATIVE_PATH=$(echo "$CLAIR3_TUMOR_VCF" | sed "s|^${WORKSPACE_DIR}/||")
            python3 "${TASK_DIR}/vspipeline-resources/vspipeline_utilities.py" update-vspipeline-json \
              --input_dir "$output_folder" \
              --sample "$tumor_sample_name" \
              --file "$RELATIVE_PATH" \
              --file_type multiverse \
              --task_name deepsomatic \
              --scratch_dir /scratch || \
              { echo "Warning: Failed to update vspipeline_inputs.json for Clair3 tumor VCF, continuing..."; }
          fi
          if [ -n "$normal_sample_name" ] && [ -f "${output_folder}/${normal_sample_name}.clair3.small_variants.correct_ref.vcf.gz" ]; then
            CLAIR3_NORMAL_VCF="${output_folder}/${normal_sample_name}.clair3.small_variants.correct_ref.vcf.gz"
            RELATIVE_PATH=$(echo "$CLAIR3_NORMAL_VCF" | sed "s|^${WORKSPACE_DIR}/||")
            python3 "${TASK_DIR}/vspipeline-resources/vspipeline_utilities.py" update-vspipeline-json \
              --input_dir "$output_folder" \
              --sample "$normal_sample_name" \
              --file "$RELATIVE_PATH" \
              --file_type multiverse \
              --task_name deepsomatic \
              --scratch_dir /scratch || \
              { echo "Warning: Failed to update vspipeline_inputs.json for Clair3 normal VCF, continuing..."; }
          fi
        else
          echo "Warning: python3 not available, skipping vspipeline_inputs.json update"
        fi

        # Copy udocker cache to output folder
        if [ "$cache_udocker_images" = true ] && [ ! -d "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}" ]; then
          mkdir -p "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}"
          cp -r /scratch/.udocker/layers /scratch/.udocker/repos "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}" 2>/dev/null || true
        fi

        echo "*************************"
        echo "DeepSomatic completed successfully"
        echo "Output files copied to: $output_folder"
        echo "*************************"
